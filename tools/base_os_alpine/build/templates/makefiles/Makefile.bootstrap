#
#  tools/base_os_alpine/build/templates/makefiles/Makefile.bootstrap
#
#  This file is written to stdout out by the command below
#  podman run docker.io/bomres/base_os_alpine make
#

BASE_OS_IMAGE   = docker.io/bomres/base_os_alpine
RESOLVER_IMAGE  = docker.io/bomres/alpine_resolver
TOOLS_IMAGE     = alpine_sandbox_base_os_tool:3.16.1

TEMPDIR=/tmp/alpine

CWD := $(shell cd -P -- '$(shell dirname -- "$0")' && pwd -P)
DIR ?= $(CWD)



help:
	@echo ""
	@echo "Build reference image"
	@echo "make config && vim product/build/base_os/config/packages && make init && make prepare"
	@echo ""
	@echo ""

_config:
	@mkdir -p $(DIR)/build
	@podman run   --rm  $(OPTIONS)  -v "$(DIR)/build:/sandbox" -w /sandbox  -e IMAGE=$(BASE_OS_IMAGE) $(BASE_OS_IMAGE)  config


_init:
	@podman run   --rm  $(OPTIONS)  -v "$(DIR)/build:/sandbox" -w /sandbox  -e IMAGE=$(BASE_OS_IMAGE) $(BASE_OS_IMAGE)  init


_prepare:
	@make -C $(DIR)/build/base_os  builder

_public_build:
	@make -C $(DIR)/build/base_os  public_build

_download:
	@make -C  $(DIR)/build/base_os  download

_private_build:
	@make -C $(DIR)/build/base_os  private_build

_test: 
	@make $(TEST_MAKEFILE)  DIR=$(DIR)
	@make -C $(DIR)/test  test DIR=$(DIR)

_sh: 
	@make $(TEST_MAKEFILE)  DIR=$(DIR)
	@make -C $(DIR)/test  sh DIR=$(DIR)

_aggregate: 
	@podman run   --rm  $(OPTIONS)  -v "$(DIR)/build:/sandbox"  $(BASE_OS_IMAGE)  aggregate

aggregate: 
	make _aggregate DIR=$(DIR)/product
config: 
	make _config DIR=$(DIR)/product
init: 
	make _init DIR=$(DIR)/product
public_build: 
	make _public_build DIR=$(DIR)/product
prepare: 
	make _prepare DIR=$(DIR)/product
download: 
	make _download DIR=$(DIR)/product
private_build: 
	make _private_build DIR=$(DIR)/product
test: 
	make _test DIR=$(DIR)/product
sh: 
	make _sh DIR=$(DIR)/product
res: 
	make _res DIR=$(DIR)/product
index: 
	make _index DIR=$(DIR)/product


clone: 
	mkdir -p $(TEMPDIR)/src $(TEMPDIR)/index $(TEMPDIR)/checkout $(TEMPDIR)/cache
	podman run  -v  $(TEMPDIR)/src:/mnt/alpine/src    $(RESOLVER_IMAGE) clone 

_index:
	podman run  -v "$(DIR)/build/base_os/sbom:/sbom" -v  "$(TEMPDIR)/src:/mnt/alpine/src" -v  "$(TEMPDIR)/checkout:/mnt/alpine/checkout"  -v  "$(TEMPDIR)/cache:/mnt/alpine/cache" $(RESOLVER_IMAGE) index

_res: 
	podman run  -v "$(DIR)/build/base_os/sbom:/sbom"  -v "$(TEMPDIR)/cache:/mnt/alpine/cache"  $(RESOLVER_IMAGE) resolve

_download_source:
	podman run  -v "$(DIR)/build/base_os/sbom:/sbom" -v "$(TEMPDIR)/src:/mnt/alpine/src" -v "$(DIR)/build/base_os/source:/source"  $(RESOLVER_IMAGE) download internal patch
	podman run  -v "$(DIR)/build/base_os/sbom:/sbom" -v "$(TEMPDIR)/src:/mnt/alpine/src" -v "$(DIR)/build/base_os/source:/source"  $(RESOLVER_IMAGE) download internal code
	podman run  -v "$(DIR)/build/base_os/sbom:/sbom" -v "$(TEMPDIR)/src:/mnt/alpine/src" -v "$(DIR)/build/base_os/source:/source"  $(RESOLVER_IMAGE) download internal build
	podman run  -v "$(DIR)/build/base_os/sbom:/sbom" -v "$(TEMPDIR)/src:/mnt/alpine/src" -v "$(DIR)/build/base_os/source:/source"  $(RESOLVER_IMAGE) download external patch
	podman run  -v "$(DIR)/build/base_os/sbom:/sbom" -v "$(TEMPDIR)/src:/mnt/alpine/src" -v "$(DIR)/build/base_os/source:/source"  $(RESOLVER_IMAGE) download external code




download_source:
	mkdir -p $(DIR)/product/build/base_os/source 
	make _download_source DIR=$(DIR)/product

.PHONY: tool
tool_config:
	@mkdir -p $(DIR)/tool/build/base_os/config/
	@podman run   --rm   -v "$(DIR)/product/build/base_os/sbom:/sbom"  $(RESOLVER_IMAGE) tool packages > $(DIR)/tool/build/base_os/config/packages
	@podman run   --rm   -v "$(DIR)/product/build/base_os/sbom:/sbom"  $(RESOLVER_IMAGE) tool settings > $(DIR)/tool/build/base_os/config/settings


tool_init: 
	make _init DIR=$(DIR)/tool
tool_prepare: 
	make _prepare DIR=$(DIR)/tool

tool_public_build: 
	make _public_build DIR=$(DIR)/tool

tool_test: 
	make _test DIR=$(DIR)/tool/test

tool_download: 
	make _download DIR=$(DIR)/tool
tool_private_build: 
	make _private_build DIR=$(DIR)/tool
tool_aggregate: 
	make _aggregate DIR=$(DIR)/tool
tool_index: 
	make _index DIR=$(DIR)/tool
tool_res: 
	make _res DIR=$(DIR)/tool

tool_download_source:
	make _download_source DIR=$(DIR)/tool

build: init config prepare public_build download private_build test aggregate
resolve: clone index res download_source  

tool_build: tool_init tool_config  tool_prepare tool_public_build tool_download tool_private_build tool_aggregate  tool/builder/Makefile tool/builder/build.sh 
tool_prod_build:   keygen  check  pkg 
tool_resolve: clone tool_index tool_res 


#
#  Rules below related to rebuild of software in product directory by use of tool ( generated by product SBOM ) 
#

# PACKAGE=prometheus-node-exporter
# REPO=community
PACKAGE=musl
REPO=main
ARCH=x86_64


shell:
	podman run -i -t  -v "$(CWD)/product/build/base_os/download:/download"  -v "$(CWD)/product/apk:/var/local/packages" -v "$(CWD)/tool/pki:/pki"  -v $(CWD)/product/build/base_os/source/repo:/aports  -v $(CWD)/tool/builder:/root $(TOOLS_IMAGE) sh 


REPOS =  $(shell ls product/build/base_os/source/repo )

ECHO      = $(shell which echo 2> /dev/null)

VERIFY_LOG=verify.log

check:
	rm -f $(VERIFY_LOG)
	@for repo in ${REPOS};                   \
	do                                      \
	for i in `ls product/build/base_os/source/repo/$${repo}`;             \
	do                                  \
		if podman run -i  -v "$(CWD)/product/apk:/var/local/packages" -v "$(CWD)/tool/pki:/pki"  -v $(CWD)/product/build/base_os/source/repo:/aports  -v $(CWD)/tool/builder:/root $(TOOLS_IMAGE) make -C /root check ARCH=${ARCH} PACKAGE=$${i} REPO=$${repo} ; then \
		   $(ECHO) -e "passed\t$${repo}\t$${i}" >> $(VERIFY_LOG);  \
                else \
		   $(ECHO) -e "failed\t$${repo}\t$${i}" >> $(VERIFY_LOG);  \
                fi \
	done                                \
	done
	sort -r $(VERIFY_LOG) >  /tmp/check.$$$$ ; cp  /tmp/check.$$$$   $(VERIFY_LOG)

BUILD_LOG=build.log

pkg:
	mkdir -p $(CWD)/product/apk
	rm -f $(PROGRESS_LOG)
	@for repo in ${REPOS};                   \
	do                                      \
	for i in `ls product/build/base_os/source/repo/$${repo}`;             \
	do                                  \
		tm=`date +"%s"`; \
		$(ECHO) -e "$$tm\tstart\t$${repo}\t$${i}" >> $(BUILD_LOG);  \
		if true ; then \
		   podman run -i  -v "$(CWD)/product/apk:/var/local/packages" -v "$(CWD)/tool/pki:/pki"  -v $(CWD)/product/build/base_os/source/repo:/aports  -v $(CWD)/tool/builder:/root $(TOOLS_IMAGE)   sh /root/build.sh  $${i} ${ARCH} $${repo}  ; \
		   tm=`date +"%s"`; \
		   $(ECHO) -e "$$tm\tstop\tOK" >> $(BUILD_LOG);  \
                else \
		   tm=`date +"%s"`; \
		   $(ECHO) -e "$$tm\tstop\tError" >> $(BUILD_LOG);  \
                fi \
	done                                \
	done

keygen:
	mkdir -p $(CWD)/tool/pki 
	openssl genrsa -out $(CWD)/tool/pki/iafw.rsa 1024
	openssl rsa -in $(CWD)/tool/pki/iafw.rsa -pubout > $(CWD)/tool/pki/iafw.rsa.pub
	chmod 755 -R $(CWD)/tool/pki

sign:
	@for repo in ${REPOS};                   \
	do                                      \
	   podman run -i -t -v "$(CWD)/product/apk:/var/local/packages" -v "$(CWD)/tool/pki:/pki"  -v $(CWD)/product/build/base_os/source/repo:/aports  -v $(CWD)/tool/builder:/root   $(TOOLS_IMAGE)  make -C /root index ARCH=${ARCH}  REPO=$${repo} ; \
	   podman run -i -t -v "$(CWD)/product/apk:/var/local/packages" -v "$(CWD)/tool/pki:/pki"  -v $(CWD)/product/build/base_os/source/repo:/aports  -v $(CWD)/tool/builder:/root  $(TOOLS_IMAGE)   make -C /root sign  ARCH=${ARCH}  REPO=$${repo} ; \
	done

TEST_MAKEFILE = $(DIR)/test/Makefile
.PHONY: $(TEST_MAKEFILE)
$(TEST_MAKEFILE) :
	mkdir -p  $(DIR)/test
	echo "" > $@
	echo "# Generated by $(BASE_OS_IMAGE)" >> $@
	echo "" >> $@
	echo "# This is a simple test that lists all packages being resolved by Alpine package manager" >> $@
	echo "# The output is included in the aggregated SBOM " >> $@
	echo "" >> $@
	echo "include ../build/base_os/config/settings" >> $@
	echo "" >> $@
	echo "CONTAINER_IMAGE = \$$(BASE_OS_IMAGE):\$$(BASE_OS_VERSION)" >> $@
	echo "" >> $@
	echo "test:" >> $@
	echo "\tpodman run   --rm  -i --entrypoint='/usr/local/bin/bom.sh'  --name alpine\$$(ALPINE_VERSION) \$$(CONTAINER_IMAGE) | tee os.bom" >> $@
	echo "sh:" >> $@
	echo "\tpodman run   --rm  -it  --name alpine\$$(ALPINE_VERSION) \$$(CONTAINER_IMAGE) sh" >> $@


BUILDER_SCRIPT = tool/builder/build.sh
.PHONY: $(BUILDER_SCRIPT)
$(BUILDER_SCRIPT) :
	mkdir -p  tool/builder
	echo "#! /bin/sh" > $@
	echo "" >> $@
	echo "# Generated, do not edit"  >> $@
	echo "" >> $@
	echo "# This is a workaround since make fails for musl " >> $@
	echo "" >> $@
	echo "build.sh PACKAGE ARCH REPO" >> $@
	echo "" >> $@
	echo "echo 'PACKAGER_PRIVKEY="/pki/iafw.rsa"' > /etc/abuild.conf" >> $@
	echo "" >> $@
	echo "rm -f /var/local/packages/\$$3/\$$2/APKINDEX.tar.gz" >> $@
	echo "mkdir -p /var/local/aports/\$$3/\$$1" >> $@
	echo "cp -r /aports/\$$3/\$$1/* /var/local/aports/\$$3/\$$1" >> $@
	echo "" >> $@
	echo "cd /var/local/aports/\$$3/\$$1 && abuild -F -P /var/local/packages" >> $@

BUILDER_MAKEFILE = tool/builder/Makefile
.PHONY: $(BUILDER_MAKEFILE)
$(BUILDER_MAKEFILE) :
	mkdir -p  tool/builder
	echo "" > $@
	echo "# Generated, do not edit"  >> $@
	echo "" >> $@
	echo "BUILD_DIR=/var/local/aports" >> $@
	echo "REPODEST=/var/local/packages" >> $@
	echo "ABUILD=abuild -F -P \$$(REPODEST)" >> $@
	echo "" >> $@
	echo "ARCH=x86_64" >> $@
	echo "PACKAGE=zlib" >> $@
	echo "REPO=main" >> $@
	echo "" >> $@
	echo "prepare:" >> $@
	echo "\t@mkdir -p \$$(BUILD_DIR)/\$$(REPO)/\$$(PACKAGE)" >> $@
	echo "\t@cp -r /aports/\$$(REPO)/\$$(PACKAGE)/*  \$$(BUILD_DIR)/\$$(REPO)/\$$(PACKAGE)" >> $@
	echo "\t@echo 'PACKAGER_PRIVKEY="/pki/iafw.rsa"' > /etc/abuild.conf" >> $@
	echo "\t@rm -f \$$(REPODEST)/\$$(REPO)/\$$(ARCH)/APKINDEX.tar.gz" >> $@
	echo "" >> $@
	echo "fetch:" >> $@
	echo "\t@( cd \$$(BUILD_DIR)/\$$(REPO)/\$$(PACKAGE) && \$$(ABUILD) fetch )" >> $@
	echo "" >> $@
	echo "verify: fetch" >> $@
	echo "\t@( cd \$$(BUILD_DIR)/\$$(REPO)/\$$(PACKAGE) && \$$(ABUILD) sanitycheck )" >> $@
	echo "\t@( cd \$$(BUILD_DIR)/\$$(REPO)/\$$(PACKAGE) && \$$(ABUILD) verify )" >> $@
	echo "" >> $@
	echo "unpack: " >> $@
	echo "\t@( cd \$$(BUILD_DIR)/\$$(REPO)/\$$(PACKAGE) && \$$(ABUILD) unpack )" >> $@
	echo "" >> $@
	echo "patch: " >> $@
	echo "\t@( cd \$$(BUILD_DIR)/\$$(REPO)/\$$(PACKAGE) && \$$(ABUILD) prepare )" >> $@
	echo "" >> $@
	echo "deps: " >> $@
	echo "\t@( cd \$$(BUILD_DIR)/\$$(REPO)/\$$(PACKAGE) && \$$(ABUILD) deps )" >> $@
	echo "" >> $@
	echo "abuild: " >> $@
	echo "\t@( cd \$$(BUILD_DIR)/\$$(REPO)/\$$(PACKAGE) && \$$(ABUILD)  )" >> $@
	echo "\t@rm -f \$$(REPODEST)/\$$(REPO)/\$$(ARCH)/APKINDEX.tar.gz" >> $@
	echo "index: " >> $@
	echo "\t@( cd \$$(REPODEST)/\$$(REPO)/\$$(ARCH)  && rm -f  APKINDEX.unsigned.tar.gz  )" >> $@
	echo "\t@( cd \$$(REPODEST)/\$$(REPO)/\$$(ARCH)  && apk index -o APKINDEX.tar.gz *.apk  )" >> $@
	echo "" >> $@
	echo "sign: " >> $@
	echo "\t@( cd \$$(REPODEST)/\$$(REPO)/\$$(ARCH)  && abuild-sign -k /pki/iafw.rsa APKINDEX.tar.gz  )" >> $@
	echo "" >> $@
	echo "build: prepare verify unpack patch abuild" >> $@
	echo "" >> $@
	echo "check: prepare verify" >> $@
	echo "" >> $@


#
# Rule that build one package , 2023-01-03 , not yet migrated to  podman
#
abuild: 
	podman run -i  -v "$(CWD)/product/apk:/var/local/packages" -v "$(CWD)/tool/pki:/pki"  -v $(CWD)/product/build/base_os/source/repo:/aports  -v $(CWD)/tool/builder:/root $(TOOLS_IMAGE)   sh /root/build.sh  $(PACKAGE) $(ARCH) $(REPO)
